/*------------------------------------------------------------
LineCommentOnOff
----------------------------------------
ModuleName:   LineCommentOnOff  EmEditor Macro
FileName:     LineCommentOnOff.jsee
Description:  プログラムの行コメントをOnOff切り替える
----------------------------------------
All  Right Reserved:
    Name:     Standard Software
    URL:      https://www.facebook.com/stndardsoftware/
--------------------------------------
Version:      2017/06/16
// ------------------------------------------------------------*/

//----------------------------------------
//include st.js
//--------------------
var fso = new ActiveXObject('Scripting.FileSystemObject')
//--------------------
var basePath = fso.GetParentFolderName(ScriptFullName);
var includeFileName = '.\\lib\\stslib_win_wsh.js'
//--------------------
eval(
  fso.OpenTextFile(
    fso.BuildPath(basePath, includeFileName), 1)
  .ReadAll()
);
//--------------------
var basePath = fso.GetParentFolderName(ScriptFullName);
var includeFileName = '.\\lib\\stslib_core.js'
//--------------------
eval(
  string_LoadFromFile(
    fso.BuildPath(basePath, includeFileName),
    encodingTypeJpCharCode.UTF8_BOM)
);
//----------------------------------------

//var OUTPUT_MODE = 'ON';
var OUTPUT_MODE = 'OFF';

//ライブラリを読み込むと
//alertが上書きされてしまうので更に上書きして対応する
var alert = function (message) {
  if (OUTPUT_MODE === 'ON') {
    OutputBar.writeln(message);
  }
};

if (OUTPUT_MODE === 'ON') {
  OutputBar.Clear();
}

(function () {

  var stsLib = require('stsLib');
  //var s = stsLib.string;

  //stsLib.test.test_stslib_core();

  //JavaScriptの命名規則
  //通常小文字から開始、コンストラクタだけ大文字開始
  //には沿っていないが、エディタ名なので先頭大文字から開始する名前空間
  stsLib.EmEditorMacro = stsLib.EmEditorMacro || {};
  (function () {
    var _ = stsLib.EmEditorMacro;

    //----------------------------------------
    //◇一般機能
    //----------------------------------------

    //最後に改行コードを含むかどうかの指定方法
    _.lastLineBreakOption = { ON:0, OFF:1 };

    //空行かどうか判断する
    _.isEmptyLine = function (line) {
      var s = stsLib.string;
      return s.isIncludeAll(line, [' ', '\t', '\r', '\n', '　']);
    };

    //----------------------------------------
    //◇行コメントアウト処理
    //----------------------------------------

    //行がコメントアウトされているかどうかを判断する関数
    _.isLineComment = function (line, commentMark) {
      //alert('isLineComment');
      var s = stsLib.string;
      commentMark = s.excludeEnd(commentMark, ' ');
      if (s.startsWith(
        s.trimStart(line, [' ', '\t']), commentMark)) {
        //alert('isLineComment True');
        return true;
      } else {
        //alert('isLineComment false');
        return false;
      }
    };

    //複数行が全てコメントアウトされているかどうか判断する関数
    _.isLinesComment = function (top, bottom, commentMark) {
      var line;
      for (var i = top; i <= bottom; i += 1) {
        line = document.GetLine(i);
        if (!_.isEmptyLine(line)) {
          if (!_.isLineComment(line, commentMark)) {
            return false;
          }
        }
      }
      return true;
    };

    //1行をコメントアウトする関数
    _.setLineCommentOn = function (line,
      indentPosition, commentMark) {
      var s = stsLib.string;
      var d = stsLib.debug;
      d.assert(indentPosition < line.length);
      return s.start(line, indentPosition) +
        commentMark +
        s.end(line, line.length - indentPosition);
    };

    //複数行をコメントアウトする関数
    _.setLinesCommentOn = function (top, bottom, commentMark, lastLineBreak) {
      var d = stsLib.debug;
      var c = stsLib.compare;
      var s = stsLib.string;
      d.assert(c.orValue(lastLineBreak,
        _.lastLineBreakOption.ON, _.lastLineBreakOption.OFF));
      var MAX_INT= 1000;
      var indent = MAX_INT;
      var line;

      //選択範囲のインデント最小値を求める
      for (var i = top; i <= bottom; i += 1) {
        line = document.GetLine(i, eeGetLineWithNewLines);
        if (!_.isEmptyLine(line)) {
          indent = Math.min(indent,
            line.length - s.trimStart(line, [' ', '\t']).length);
        }
      }
      //alert('indent:' + indent);
      if (indent === MAX_INT) {
        indet = 0;
      }
      var result = '';
      for (var i = top; i <= bottom; i += 1) {
        line = document.GetLine(i, eeGetLineWithNewLines);
        if (!_.isEmptyLine(line)) {
          result += _.setLineCommentOn(line, indent, commentMark);
        } else {
          result += line;
        }
      }
      if (lastLineBreak === _.lastLineBreakOption.OFF) {
        return s.trimEnd(result, ['\r', '\n']);
      } else {
        return result;
      }
    }

    //1行をコメント解除する関数
    _.setLineCommentOff = function (line, commentMark) {
      var s = stsLib.string;
      if (_.isLineComment(line, commentMark)) {
        var commentMarkTrimEnd = s.excludeEnd(commentMark, ' ');
        if (commentMark === commentMarkTrimEnd) {
          return s.startFirstDelim(line, commentMark) +
            s.endFirstDelim(line, commentMark);
        } else {
          var index1 = s.indexOfFirst(line, commentMark);
          var index2 = s.indexOfFirst(line, commentMarkTrimEnd);
          if (index1 === -1) {
            return s.startFirstDelim(line, commentMarkTrimEnd) +
              s.endFirstDelim(line, commentMarkTrimEnd);
          } else if (index1 <= index2) {
            return s.startFirstDelim(line, commentMark) +
              s.endFirstDelim(line, commentMark);
          } else {
            return s.startFirstDelim(line, commentMarkTrimEnd) +
              s.endFirstDelim(line, commentMarkTrimEnd);
          }
        }
      } else {
        return line;
      }
    };

    //複数行をコメント解除する関数
    _.setLinesCommentOff = function (top, bottom, commentMark, lastLineBreak) {
      var d = stsLib.debug;
      var c = stsLib.compare;
      d.assert(c.orValue(lastLineBreak,
        _.lastLineBreakOption.ON, _.lastLineBreakOption.OFF));
      var line;
      var result = '';
      for (var i = top; i <= bottom; i += 1) {
        line = document.GetLine(i, eeGetLineWithNewLines);
        result += _.setLineCommentOff(line, commentMark);
      }

      if (lastLineBreak === _.lastLineBreakOption.OFF) {
        return s.trimEnd(result, ['\r', '\n']);
      } else {
        return result;
      }
    };

    //複数行のコメントを切り替える関数
    _.setLinesCommentOnOff = function (top, bottom, commentMark, lastLineBreak) {
      //全行がコメントアウトならコメント解除
      if (_.isLinesComment(top, bottom, commentMark)) {
        alert('setLinesCommentOff')
        return _.setLinesCommentOff(top, bottom, commentMark, lastLineBreak);
      } else {
        alert('setLinesCommentOn')
        return _.setLinesCommentOn(top, bottom, commentMark, lastLineBreak);
      }
    };

    //----------------------------------------
    //◇行選択にする
    //----------------------------------------
    //  ・  lastLineBreakOption で
    //      最終行の改行コードまで選択するかしないかを選べる
    //  ・  lastLineBreakOption.OFFだと
    //      少しちらつく
    //      document.GetLine のためだと思われる
    //----------------------------------------
    _.selectLinesTopToBottom = function (top, bottom, lastLineBreak) {
      var d = stsLib.debug;
      var c = stsLib.compare;
      d.assert(top <= bottom);
      d.assert(c.orValue(lastLineBreak,
        _.lastLineBreakOption.ON, _.lastLineBreakOption.OFF));
      switch (lastLineBreak) {
      case _.lastLineBreakOption.ON:
        sel.SetActivePoint(eePosLogical, 1, top, false);
        sel.SetActivePoint(eePosLogical, 1, bottom + 1, true);
        break;
      case _.lastLineBreakOption.OFF:
        var lineLength = document.GetLine(bottom).length;
        sel.SetActivePoint(eePosLogical, 1, top, false);
        sel.SetActivePoint(eePosLogical,
          lineLength + 1, bottom, true);
        break;
      }
    };

    _.selectLinesBottomToTop = function (top, bottom, lastLineBreak) {
      var d = stsLib.debug;
      var c = stsLib.compare;
      d.assert(top <= bottom);
      d.assert(c.orValue(lastLineBreak,
        _.lastLineBreakOption.ON, _.lastLineBreakOption.OFF));
      switch (lastLineBreak) {
      case _.lastLineBreakOption.ON:
        sel.SetActivePoint(eePosLogical, 1, bottom + 1, false);
        sel.SetActivePoint(eePosLogical, 1, top, true);
        break;
      case _.lastLineBreakOption.OFF:
        sel.SetActivePoint(eePosLogical,
          document.GetLine(bottom).length + 1, bottom, false);
        sel.SetActivePoint(eePosLogical, 1, top, true);
        break;
      }
    };

  }());

  var e = stsLib.EmEditorMacro;
  var s = stsLib.string;

  //----------------------------------------
  //◇設定
  //----------------------------------------

  //動作モードを選択ラスト改行ありにする
  var lastLineBreak = e.lastLineBreakOption.ON;

  //行コメントアウト記号取得
  var lineCommentMark = document.Config.Highlight.LineComment1;
  //行コメントアウト記号の最後にスペースを追加
  lineCommentMark = stsLib.string.includeEnd(lineCommentMark, ' ');
  //※コメントアウト記号２は無視する

  var commentBegin = document.Config.Highlight.CommentBegin;
  var commentEnd = document.Config.Highlight.CommentEnd;

  //----------------------------------------
  //◇本体
  //----------------------------------------

  var sel = document.selection;
  var topY = sel.GetTopPointY(eePosLogical);
  var bottomY = sel.GetBottomPointY(eePosLogical);

  //行選択状態で最後に改行コードがついている場合は
  //処理範囲のtopとbottomを正しく修正している
  if (topY !== bottomY) {
    //複数行選択
    if (sel.GetBottomPointX(eePosLogical) === 1) {
      //下の選択が1列目=最終文字は改行含めた選択
      alert('bottomY -= 1;');
      bottomY -= 1;
    }
  }

  var trimSpaceOnly = function (str) {
    return s.trimBothEnds(str, [' ']);
  };

  var trimCutStart = function (str, trimStrArray) {
    var s = stsLib.string;
    return s.start(str, str.length - s.trimStart(str, trimStrArray).length);
  };

  var trimCutEnd = function (str, trimStrArray) {
    var s = stsLib.string;
    return s.end(str, str.length - s.trimEnd(str, trimStrArray).length)
  };

  var setCommentOnOff = function (top, bottom, commentBegin, commentEnd) {
    var s = stsLib.string;
    var d = stsLib.debug;
    d.assert(top <= bottom);

    if (top === bottom) {
      var line = document.GetLine(top, eeGetLineWithNewLines);
      var lienAfterTrim =
        s.trimStart(
          s.trimEnd(line, [' ', '\t', '\r', '\n'])
          , [' ', '\t']);
      if ((s.startsWith(lienAfterTrim, commentBegin))
      && (s.endsWith(lienAfterTrim, commentEnd))) {
        //コメントアウトされている場合
        //コメントアウト記号を取り除く
        return trimCutStart(line, [' ', '\t']) +
          s.excludeEnd(
            s.excludeStart(lienAfterTrim, commentBegin), 
            commentEnd) +
          trimCutEnd(line, [' ', '\t', '\r', '\n']);
      } else {
        //コメントアウトされていない場合
        //コメントアウト記号を追加
        return trimCutStart(line, [' ', '\t']) +
          commentBegin + 
          lienAfterTrim + 
          commentEnd + 
          trimCutEnd(line, [' ', '\t', '\r', '\n']);
      }
    } else {
      var lineTop = document.GetLine(top, eeGetLineWithNewLines);
      var lineTopAfterTrim = s.trimStart(lineTop, [' ', '\t']);
      var lineBottom = document.GetLine(bottom, eeGetLineWithNewLines);
      var lineBottomAfterTrim = s.trimEnd(lineBottom, [' ', '\t', '\r', '\n']);

      var textCenter = '';
      for (var i = top + 1; i <= bottom - 1; i += 1) {
        textCenter += document.GetLine(i, eeGetLineWithNewLines);
      }
      if ((s.startsWith(lineTopAfterTrim, commentBegin))
      && (s.endsWith(lineBottomAfterTrim, commentEnd))) {
        //コメントアウトされている場合
        //コメントアウト記号を取り除く
        return trimCutStart(lineTop, [' ', '\t']) +
          s.excludeStart(lineTopAfterTrim, commentBegin) +
          textCenter +
          s.excludeEnd(lineBottomAfterTrim, commentEnd) +
          trimCutEnd(lineBottom, [' ', '\t', '\r', '\n']);
      } else {
        //コメントアウトされていない場合
        //コメントアウト記号を追加
        return trimCutStart(lineTop, [' ', '\t']) +
          commentBegin +
          lineTopAfterTrim +
          textCenter +
          lineBottomAfterTrim +
          commentEnd +
          trimCutEnd(lineBottom, [' ', '\t', '\r', '\n']);
      }
    }
  };

  if (s.isEmpty(trimSpaceOnly(lineCommentMark))) {
    //行コメントアウト記号がない
    //＝ほとんどの場合はHTML
    if (s.isEmpty(trimSpaceOnly(commentBegin))
    || s.isEmpty(trimSpaceOnly(commentEnd))) {
      //開始終了コメント記号が無い場合は
      //何もしない
    } else {

      if (topY === bottomY) {
        alert('選択範囲が単一行の場合');

        //行選択
        e.selectLinesTopToBottom(topY, bottomY, lastLineBreak);
        sel.Text = setCommentOnOff(topY, bottomY, commentBegin, commentEnd);
        e.selectLinesTopToBottom(topY, bottomY, lastLineBreak);
      } else {
        alert('選択範囲が複数行の場合');
        if (sel.GetActivePointY(eePosLogical) !== topY) {
          alert('複数行選択:上から下');
          e.selectLinesTopToBottom(topY, bottomY, lastLineBreak);
          sel.Text = setCommentOnOff(topY, bottomY, commentBegin, commentEnd);
          e.selectLinesTopToBottom(topY, bottomY, lastLineBreak);

        } else {
          alert('複数行選択:下から上');
          e.selectLinesBottomToTop(topY, bottomY, lastLineBreak);
          sel.Text = setCommentOnOff(topY, bottomY, commentBegin, commentEnd);
          e.selectLinesBottomToTop(topY, bottomY, lastLineBreak);
        }
      }

    }
  } else {
    //行コメントアウト記号がある
    //＝テキストかC++やJavaScriptなどの言語

    if (topY === bottomY) {
      alert('選択範囲が単一行の場合');

      //行選択
      e.selectLinesTopToBottom(topY, bottomY, lastLineBreak);
      sel.Text = e.setLinesCommentOnOff(topY, bottomY,
        lineCommentMark, lastLineBreak);
      e.selectLinesTopToBottom(topY, bottomY, lastLineBreak);
    } else {
      alert('選択範囲が複数行の場合');
      if (sel.GetActivePointY(eePosLogical) !== topY) {
        alert('複数行選択:上から下');
        e.selectLinesTopToBottom(topY, bottomY, lastLineBreak);
        sel.Text = e.setLinesCommentOnOff(topY, bottomY,
          lineCommentMark, lastLineBreak);
        e.selectLinesTopToBottom(topY, bottomY, lastLineBreak);

      } else {
        alert('複数行選択:下から上');
        e.selectLinesBottomToTop(topY, bottomY, lastLineBreak);
        sel.Text = e.setLinesCommentOnOff(topY, bottomY,
          lineCommentMark, lastLineBreak);
        e.selectLinesBottomToTop(topY, bottomY, lastLineBreak);
      }
    }

  }

  alert('finish');
}());